---
title: "Leaflet by Example: Election 2000"
date: 2016-05-15
slug: "leaflet-election-2000"
tags: ["geospatial", "R", "visualization", "leaflet"]
---



<p>If you’ve kept your finger on the pulse of the R community lately, you’d likely agree that innovation has been on a tear! A foundation built on extensibility combined with a growing user base amount to daily announcements of new products, new packages, new features and new ideas. One of the more impressive items to arrive in the past year or two is the <a href="http://www.htmlwidgets.org/">htmlwidgets</a> package. If you’re not already familiar, this package provides a framework for bringing interactive JavaScript visualizations to R, where they can then be easily embedded into R Markdown documents and Shiny web applications.</p>
<p>Using this framework, developers can create new widgets that bind R and JavaScript in amazingly seamless ways. Many such R packages already exist, and while each provides useful and unique tools for presenting and visualizing data, one in particular stands out for its geospatial capabilities. <a href="https://rstudio.github.io/leaflet/">Leaflet</a> gives users the ability to create interactive maps that can span the entire globe or drill down to a street level. With a variety of different base maps (tiles) and the ability to overlay multiple layers of content (including markers, pop-ups, lines, shapes, etc…), the applications for leaflet are endless. This article is focused on demonstrating a handful of leaflet’s many great features using real world data.</p>
<p>In the United States, a <a href="https://www.hillaryclinton.com/">Clinton (D)</a> vs. <a href="https://www.donaldjtrump.com/">Trump (R)</a> showdown is all but certain for the upcoming presidential election in November. There has been a lot of rhetoric tossed around during the primaries and, if those debates were any indication, we are all in for some very entertaining months ahead. During election years, I’m often reminded of the 2000 presidential election that pitted incumbent vice president <a href="https://www.algore.com/">Al Gore (D)</a> vs. incumbent Texas governor <a href="http://www.georgewbush.com/">George W. Bush (R)</a>. One of the closest presidential elections in U.S. history, and certainly the most publicized one, 2000 saw Bush defeat Gore by only 5 electoral votes despite Gore winning the popular vote by half a percent. To better understand how the votes shook out, let’s create a leaflet map to visualize who carried which states and by how many votes.</p>
<p><em>Note about changes</em></p>
<div id="necessary-packages" class="section level4">
<h4>Necessary Packages</h4>
<p>First thing we must do is load some additional packages that we’ll need along the way. Ultimately, we’re going to be fetching the election result data from the web, cleaning it up a bit, combining it with state boundary shape data and then plotting it using leaflet. There are a number of packages and functions capable of getting the data and preparing it for the final plot, but the ones I’ve chosen here, I’ve found to be a little more reliable and independent than some of the alternatives.</p>
<pre class="r"><code>library(maptools)</code></pre>
<pre><code>## Loading required package: sp</code></pre>
<pre><code>## Checking rgeos availability: FALSE
##      Note: when rgeos is not available, polygon geometry     computations in maptools depend on gpclib,
##      which has a restricted licence. It is disabled by default;
##      to enable gpclib, type gpclibPermit()</code></pre>
<pre class="r"><code>library(httr)
library(xml2)
library(rvest)
library(dplyr)</code></pre>
<pre><code>## 
## Attaching package: &#39;dplyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union</code></pre>
<pre class="r"><code>library(leaflet)</code></pre>
</div>
<div id="state-boundary-data" class="section level4">
<h4>State Boundary Data</h4>
<p>Since we are interested in seeing the election results by state, we’ll need to obtain a shape file for U.S. states. Fortunately, the United States Census Bureau provides a variety of cartographic boundary (shape) files. This shape data is available to download, from their website, in a compressed (zipped) format. Using a few utility functions, we can easily download and unzip the data to our working directory. Next, we have to import the shape data. For this we will use <code>maptools::readShapePoly()</code>.</p>
<pre class="r"><code>download.file(
    &quot;http://www2.census.gov/geo/tiger/GENZ2015/shp/cb_2015_us_state_20m.zip&quot;,
    &quot;cb_2015_us_state_20m.zip&quot;
)
unzip(
    &quot;cb_2015_us_state_20m.zip&quot;,
    exdir = &quot;cb_2015_us_state_20m&quot;
)
stateMap &lt;- readShapePoly(fn = &quot;cb_2015_us_state_20m/cb_2015_us_state_20m&quot;)</code></pre>
<pre><code>## Warning: readShapePoly is deprecated; use rgdal::readOGR or sf::st_read</code></pre>
</div>
<div id="election-result-data" class="section level4">
<h4>Election Result Data</h4>
<p>Now we need our actual election results, by state, in a data frame. There are a number of options for obtaining this data, but one particularly convenient option involves scraping it directly from <a href="https://www.infoplease.com/">Infoplease</a>. We can use <code>httr::GET()</code> along with <code>xml2::read_html()</code> and <code>rvest::html_table()</code> to pull directly into R the state tabulated results. Note that we have to do some basic manipulation in order to:</p>
<ol style="list-style-type: decimal">
<li>Extract the initial data frame from a list</li>
<li>Remove the header and total rows from the actual data</li>
<li>Convert formatted numbers to integers</li>
<li>Assign new column names</li>
<li>Derive new fields</li>
</ol>
<pre class="r"><code>x &lt;- GET(&quot;https://www.infoplease.com/us/government/elections/presidential-election-of-2000-electoral-and-popular-vote-summary&quot;)
x &lt;- html_table(read_html(rawToChar(x$content)))
x &lt;- x[[1]]
x &lt;- x[2:(nrow(x) - 1), c(1:5, 8:9)]
for (i in 2:7) {
    x[, i] &lt;- as.integer(gsub(&quot;[^0-9]&quot;, &quot;&quot;, x[, i]))
}
names(x) &lt;- c(
    &quot;StateName&quot;,
    &quot;PopularBush&quot;,
    &quot;PopularMixBush&quot;,
    &quot;PopularGore&quot;,
    &quot;PopularMixGore&quot;,
    &quot;ElectoralBush&quot;,
    &quot;ElectoralGore&quot;
)
x$ElectoralVotes &lt;- ifelse(is.na(x$ElectoralBush), x$ElectoralGore, x$ElectoralBush)
x$Winner &lt;- ifelse(is.na(x$ElectoralBush), &quot;Gore&quot;, &quot;Bush&quot;)
x$StateName &lt;- ifelse(
    x$StateName == &quot;DC&quot;,
    &quot;District of Columbia&quot;,
    x$StateName
)
stateResults &lt;- x</code></pre>
</div>
<div id="combine-data" class="section level4">
<h4>Combine Data</h4>
<p>While it’s possible to reference disjoint data within leaflet, it’s much easier to reference a single data frame with all of your information. If you’ve inspected the <code>stateMap</code> object so far, you’ve probably noticed that its structure appears to be complex. Fortunately, we don’t need to worry too much about that. However, it’s important to know that this structure is sort of like a list where each immediate element is a “state”. In fact, by running <code>length(stateMap)</code>, you’ll see that it has 52 elements, which is 1 more than the number of observations in our election result data (50 states plus the District of Columbia). This additional element belongs to <a href="https://en.wikipedia.org/wiki/Federal_voting_rights_in_Puerto_Rico">Puerto Rico</a>, which is a U.S. territory and does not have voting representation in congress nor is entitled to electoral votes for president. We can use the base function <code>subset()</code> to remove Puerto Rico from our shape data and then <code>dplyr::inner_join()</code> to join our election data to the <em>data object</em> in <code>stateMap</code>.</p>
<pre class="r"><code>x &lt;- subset(stateMap, stateMap$NAME %in% stateResults$StateName)
x$StateName &lt;- as.character(x$NAME)
x@data &lt;- x@data %&gt;% 
    inner_join(stateResults, &quot;StateName&quot;)</code></pre>
</div>
<div id="color-conscious" class="section level4">
<h4>Color Conscious</h4>
<p>At this point, all of the data needed for our plot is stored inside the object <code>x</code>. Since we’d like to color each state by its winner, we’ll need to create a function for mapping each candidate to a color. Leaflet has some nice color mapping functions specifically for this purpose, so we’ll use <code>leaflet::colorFactor()</code> to map, in traditional partisan fashion, <span style="color: red; font-weight: bold">red</span> to Governor Bush and <span style="color: blue; font-weight: bold">blue</span> to Vice President Gore.</p>
<pre class="r"><code>pal &lt;- colorFactor(palette = c(&quot;Red&quot;, &quot;Blue&quot;), domain = c(&quot;Bush&quot;, &quot;Gore&quot;))</code></pre>
</div>
<div id="map-creation" class="section level4">
<h4>Map Creation</h4>
<p>Finally, we are ready to create our map using <code>leaflet::leaflet()</code>. Like many packages, leaflet imports the forward pipe operator (<code>%&gt;%</code>) from the magrittr package. This allows you to construct a logical pipeline of features while avoiding nesting functions, which could quickly become difficult to code, read and troubleshoot. One of the first things you’ll want to do with any leaflet map is call <code>addTiles()</code> or <code>addProviderTiles()</code>. This adds a basemap layer. By calling <code>addTiles()</code> with no arguments, you’ll get <a href="https://www.openstreetmap.org/#map=5/51.500/-0.100">OpenStreetMap</a> tiles which look great and suffice for many applications. For our map, though, since we’re going to overlay a lot of color, I want to use simple black and white tiles (see <a href="http://leaflet-extras.github.io/leaflet-providers/preview/index.html">here</a> for the complete set of available tiles). Next, we set the initial center coordinates and zoom level for our viewing window. Remember, these are interactive maps and you’ll be able to zoom in and out and drag all around. The options specified below result in a well centered view of the continental United States. Now we can add our shape data, which we do using <code>addPolygons()</code>. For this, we point to our shape data object (<code>x</code>) and can then make attached references to the columns in <code>x@data</code> using <code>= ~</code>. Our state borders will be colored white with a weight of 2, while the interior of the states will be colored according to our palette function and the value of the <code>x@data$Winner</code> field for that particular state. Another great feature of leaflet maps is the ability to add pop-ups, which can be constructed inside <code>addPolygons()</code> (among other <code>add*()</code> functions). Here, we’ll paste together some of the information from our data and use a little HTML to make it render nicely. Lastly, we’ll add a legend to let users know which color goes with which candidate.</p>
<pre class="r"><code># leaflet() %&gt;% 
#     addProviderTiles(&quot;OpenStreetMap.BlackAndWhite&quot;) %&gt;% 
#     setView(lng = -98.35,
#             lat = 39.50,
#             zoom = 4) %&gt;% 
#     addPolygons(data = x,
#                 color = &quot;#FFFFFF&quot;,
#                 weight = 2,
#                 fillColor = ~ pal(Winner),
#                 fillOpacity = 0.80,
#                 popup = ~ paste0(
#                     &quot;&lt;b&gt;&quot;, NAME, &quot;&lt;/b&gt;&quot;, &quot;(&quot;, STUSPS, &quot;)&quot;,
#                     &quot;&lt;br&gt;&quot;, &quot;Winner: &quot;, &quot;&lt;b&gt;&quot;, Winner, &quot;&lt;/b&gt;&quot;,
#                     &quot;&lt;br&gt;&quot;, &quot;Electoral Votes: &quot;, &quot;&lt;b&gt;&quot;, ElectoralVotes, &quot;&lt;/b&gt;&quot;,
#                     &quot;&lt;br&gt;&quot;, &quot;Popular # (Bush): &quot;, &quot;&lt;b&gt;&quot;, format(PopularBush, big.mark = &quot;,&quot;), &quot;&lt;/b&gt;&quot;,
#                     &quot;&lt;br&gt;&quot;, &quot;Popular % (Bush): &quot;, &quot;&lt;b&gt;&quot;, PopularMixBush, &quot;%&lt;/b&gt;&quot;,
#                     &quot;&lt;br&gt;&quot;, &quot;Popular # (Gore): &quot;, &quot;&lt;b&gt;&quot;, format(PopularGore, big.mark = &quot;,&quot;), &quot;&lt;/b&gt;&quot;,
#                     &quot;&lt;br&gt;&quot;, &quot;Popular % (Gore): &quot;, &quot;&lt;b&gt;&quot;, PopularMixGore, &quot;%&lt;/b&gt;&quot;
#                 )) %&gt;% 
#     addLegend(position = &quot;bottomleft&quot;,
#               pal = pal,
#               values = c(&quot;Bush&quot;, &quot;Gore&quot;))</code></pre>
</div>
